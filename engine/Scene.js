/*
	Сцена - то, что на данный момент является актуальным, действующим выступлением.
	Меню - одна сцена. Игра - другая сцена.
	Третья сцена между матчами, где показаны счет, уровень.
	Сцена унаследована от Контейнера (расширенный Контейнер).
	Отличие в том, что есть псевдоним stage. Он ссылается на тот же объект, что и displayObjects.
*/
;(function () {
	'use strict'

	class Scene extends GameEngine.Container {
		constructor (args = {}) {
			super() // при наследовании класса вызывать обязательно

			// По умолчанию сцена не стартует автоматически.
			this.autoStart = args.autoStart || false
			// Имя сцены
			this.name = args.name || ''
			
			// По умолчанию статус: Ожидание
			this.status = 'waiting'
			// stage - коллекция всех дочерних элементов Сцены
			this.stage = this.displayObjects
			// Игра, в которой находится сцена:
			this.game = null

			if (args.loading) {
				/*
					args.loading - здесь функция.
					bind создает копию функции, но заранее привязывает контекст.
					Теперь когда при создании экземпляра этого класса 
					внутри этой функции мы будем обращаться к this,
					то мы будем обращаться непосредственно к экзмпляру этого класса.
				*/
				this.loading = args.loading.bind(this)
			}

			if (args.init) {
				/*
					args.init - здесь функция.
					bind создает копию функции, но заранее привязывает контекст
					Теперь когда при создании экземпляра этого класса 
					внутри этой функции мы будем обращаться к this,
					то мы будем обращаться непосредственно к экзмпляру этого класса.
				*/
				this.init = args.init.bind(this)
			}

			if (args.update) {
				/*
					args.update - здесь функция.
					bind создает копию функции, но заранее привязывает контекст
					Теперь когда при создании экземпляра этого класса 
					внутри этой функции мы будем обращаться к this,
					то мы будем обращаться непосредственно к экзмпляру этого класса.
				*/
				this.update = args.update.bind(this)
			}

			if (args.beforeDestroy) {
				/*
					args.update - здесь функция.
					bind создает копию функции, но заранее привязывает контекст
					Теперь когда при создании экземпляра этого класса 
					внутри этой функции мы будем обращаться к this,
					то мы будем обращаться непосредственно к экзмпляру этого класса.
				*/
				this.beforeDestroy = args.beforeDestroy.bind(this)
			}
		}

		loading () {}
		init () {}
		update () {}
		/*
			Метод beforeDestroy() будет вызываться после того,
			как сцена отжила своё, перед удалением сцены.
			Если в функции init() подпишемся на события
			(мыши, клавиатуры - в обход Keyboard'a, от сервера, сокеты),
			эти зависимости (все, что создали в init() ) нужно будет удалить.
			Чтобы не занимать память. Пока сцена слушает события,
			сборщик мусора не сможет её удалить.
		*/
		beforeDestroy () {
			// Если beforeDestroy() не была встроена извне:
			/*for (const key of Object.keys(this)) {
				delete this[key]
			}*/
		}
	}

	window.GameEngine = window.GameEngine || {}
	window.GameEngine.Scene = Scene
})();